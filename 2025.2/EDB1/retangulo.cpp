/*!
 * @brief This code implements the Intervalos programming problem
 * @author selan
 * @data June, 6th 2021
 */

#include <iostream>
#include <fstream>
#include <iomanip>

/// This class represents a XY aligned rectangle.
struct Rect {
  float x, y; //!< Coordinates of the origin -> Bottom-left corner.
  float w;    //!< Width
  float h;    //!< Height
  // Ctro.
  Rect(float x_ = 0, float y_ = 0, float w_ = 0, float h_ = 0)
      : x{x_}, y{y_}, w{w_}, h{h_} { /*empty*/ }
};


bool point_intersection(const Rect &R,float x, float y){
    bool intervalox = false, intervaloy = false; 
    if(R.x < x && x < R.x+R.w){
        intervalox = true;
    }
    if(R.y < y && y < R.y+R.h){
        intervaloy = true;
    }
    if(intervalox && intervaloy){
        return true;
    }
    return false;
}



/// Returns true if there is a intersection between 2 rectangles.
bool has_intersection(const Rect &R, const Rect &S) {
  int count{};
  if(point_intersection(R, S.x, S.y)){
    count++;
  }
  if(point_intersection(R, S.x+S.w, S.y+S.h)){
    count++;
  }
  if(point_intersection(R, S.x, S.y+S.h)){
    count++;
  }
  if(point_intersection(R, S.x+S.w, S.y)){
    count++;
  }
  if(count > 0){
    return true;
  }



  return false;
}

/*! Determines and returns a rectangle that represents the intersection between
 *  the two rectangles passes as arguments. If there is no intersection, the
 *  function returns nothing.
 *  @param R the first rectangle
 *  @param S the second rectangle
 *  @return The rectangle generated by the intersection between R and S, if
 * there is one.
 */
Rect intersect(const Rect &R, const Rect &S) {
  Rect resultado;
  bool rig_sup = false;
  bool lef_sup = false;
  bool rig_inf = false;
  bool lef_inf = false;

  if(point_intersection(R, S.x, S.y)){
    lef_inf = true;
  }
  if(point_intersection(R, S.x+S.w, S.y+S.h)){
    rig_sup = true;
  }
  if(point_intersection(R, S.x, S.y+S.h)){
    lef_sup = true;
  }
  if(point_intersection(R, S.x+S.w, S.y)){
    rig_inf = true;
  }
  if(lef_inf && rig_sup && lef_sup && rig_inf){
    return S;
  }
  if(lef_sup && rig_sup){
    resultado.x = S.x;
    resultado.y = R.y;
    resultado.w = S.w;
    resultado.h = S.y+S.h - R.y; 
    return resultado;
  }
  if(lef_inf && rig_inf){
    resultado.x = S.x;
    resultado.y = S.y;
    resultado.w = S.w;
    resultado.h = R.y+R.h - S.y;
    return resultado;
  }
  if(lef_inf && lef_sup){
    resultado.x = S.x;
    resultado.y = S.y;
    resultado.w = R.x+R.w - S.x;
    resultado.h = S.h;
    return resultado;
  }
  if(rig_inf && rig_sup){
    resultado.x = R.x;
    resultado.y = S.y;
    resultado.w = S.x+S.w - R.x;
    resultado.h = S.h;
  }

  if(lef_inf){
    resultado.x = S.x;
    resultado.y = S.y;
    resultado.w = R.x+R.w - S.x;
    resultado.h = R.y+R.h - S.y;
    return resultado;
  }
  if(rig_sup){
    resultado.x = R.x;
    resultado.y = R.y;
    resultado.w = S.x+S.w - R.x;
    resultado.h = S.y+S.h - R.y;
    return resultado;
  }
  if(lef_sup){
    resultado.x = S.x;
    resultado.y = R.y;
    resultado.w = R.x+R.w - S.x;
    resultado.h = S.y+S.h - R.y;
    return resultado;
  }
  if(rig_inf){
    resultado.x = R.x;
    resultado.y = S.y;
    resultado.w = S.x+S.w - R.x;
    resultado.h = R.y+R.h - S.y;
    return resultado;
  }
  






  return Rect{};
}

int main() {
  Rect R1;
  Rect S1;

  Rect R2;
  Rect S2;

  Rect R3;
  Rect S3;

  Rect R4;
  Rect S4;

  Rect resultado;
  //std::ifstream canal_in("input01.txt");
  //std::ofstream canal_out("input01_OUT.txt")
  std::cin >> R1.x >> R1.y >> R1.w >> R1.h;
  std::cin >> S1.x >> S1.y >> S1.w >> S1.h;

  //canal_in >> R2.x >> R2.y >> R2.w >> R2.h;
  //canal_in >> S2.x >> S2.y >> S2.w >> S2.h;

  //canal_in >> R3.x >> R3.y >> R3.w >> R3.h;
  //canal_in >> S3.x >> S3.y >> S3.w >> S3.h;

  //canal_in >> R4.x >> R4.y >> R4.w >> R4.h;
  //canal_in >> S4.x >> S4.y >> S4.w >> S4.h;
  if(has_intersection(R1, S1) == false && has_intersection(S1, R1) == false){
    std::cout << "sem intersecao\n";
  }
  else{
    if(R1.w * R1.h > S1.w * R1.h){
      resultado = intersect(R1, S1);
    }
    else{
      resultado = intersect(S1, R1);
    }
    std::cout << std::fixed << std::setprecision(2) << resultado.x << " " << resultado.y << " " << resultado.w << " " << resultado.h << '\n';
  }

  //if(has_intersection(R2, S2) == false && has_intersection(S2, R2) == false){
    //std::cout << "sem intersecao\n";
  //}
  //else{
    //if(R2.w * R2.h > S2.w * R2.h){
      //resultado = intersect(R2, S2);
    //}
    //else{
      //resultado = intersect(S2, R2);
    //}
    //canal_out << resultado.x << resultado.y << resultado.w << resultado.h << '\n';
  //}

  //if(has_intersection(R3, S3) == false && has_intersection(S3, R3) == false){
    //std::cout << "sem intersecao\n";
  //}
  //else{
    //if(R3.w * R3.h > S3.w * R3.h){
      //resultado = intersect(R3, S3);
    //}
    //else{
      //resultado = intersect(S3, R3);
    //}
    //canal_out << resultado.x << resultado.y << resultado.w << resultado.h << '\n';
  //}

  //if(has_intersection(R4, S4) == false && has_intersection(S4, R4) == false){
    //std::cout << "sem intersecao\n";
  //}
  //else{
    //if(R4.w * R4.h > S4.w * R4.h){
      //resultado = intersect(R4, S4);
    //}
    //else{
      //resultado = intersect(S4, R4);
    //}
    //canal_out << resultado.x << resultado.y << resultado.w << resultado.h << '\n';
  //}
  return 0;
}
